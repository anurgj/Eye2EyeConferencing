<!--  -->
<template>
  <div ref="canvas" class="canvas">
    <!-- id增加动态传入 -->

    <!-- 多个数据时，id不能重复 -->
    <canvas
      v-if="obj.id"
      :id="obj.id"
      :width="canvasWidth"
      :height="canvasHeight"
      :style="{ transform: `scale(${scaleNum})` }"
    ></canvas>
    <canvas
      v-else
      id="dst"
      :width="canvasWidth"
      :height="canvasHeight"
      :style="{ transform: `scale(${scaleNum})` }"
    ></canvas>
  </div>
</template>
  
  <script>
export default {
  props: {
    obj: {
      type: Object,
      default: {
        width: 500,
        height: 400,
        ssrc: 0,
        // id: 1,
        codec: 'avc1.4D6029'
      }
    },
    urlSrc: {
      type: String
    }
  },

  components: {},

  data() {
    return {
      canvasWidth: 653,
      canvasHeight: 367,
      videoFirst: true,
      writerObj: null,
      scaleNum: 1 //缩放自适应
    }
  },

  computed: {},

  mounted() {
    // canvas自适应
    window.addEventListener('resize', () => {
      this.setCanvasSize(true)
    })
    this.$nextTick(() => {
      this.setCanvasSize()
      this.loadVideo()
    })
  },
  async beforeDestroy() {
    await this.writerObj.close()
    this.writerObj = null
  },

  methods: {
    //计算宽高比例重新设置canvas宽高
    setCanvasSize(flag) {
      let canvas = this.$refs.canvas
      let width = canvas.offsetWidth
      let height = canvas.offsetHeight
      let ratio = this.obj.width / this.obj.height
      if (width / height > ratio) {
        if (!flag) {
          this.canvasWidth = height * ratio
          this.canvasHeight = height
        }
        this.scaleNum = (height * ratio) / this.canvasWidth
      } else {
        if (!flag) {
          this.canvasWidth = width
          this.canvasHeight = width / ratio
        }
        this.scaleNum = width / ratio / this.canvasHeight
      }
    },

    async loadVideo() {
      var _this = this
      const url = _this.urlSrc
      let transport = new WebTransport(url)
      transport.closed
        .then(() => {
          console.log('视频WebTransport的连接关闭了')
        })
        .catch((error) => {
          console.error('视频WebTransport的连接出错了：', error)
        })
      await transport.ready

      let cnv = document.getElementById(_this.obj.id ? _this.obj.id : 'dst')
      let ctx = cnv.getContext('2d', { alpha: false })
      let ready_frames = []

      async function renderFrame() {
        if (ready_frames.length == 0) {
          return
        }
        let frame = ready_frames.shift()
        ctx.drawImage(frame, 0, 0, _this.canvasWidth, _this.canvasHeight)
        setTimeout(renderFrame, 0)
        frame.close()
      }
      function handleFrame(frame) {
        ready_frames.push(frame)
        setTimeout(renderFrame, 0)
      }

      let bidirectionalStream = await transport.createBidirectionalStream()
      const reader = bidirectionalStream.readable.getReader()
      this.writerObj = bidirectionalStream.writable.getWriter()
      _this.videoFirst = true
      let ssrcUint8 = new Uint8Array(4)
      const ssrc = new DataView(ssrcUint8.buffer)
      let beginOffset = 0
      let lastData
      lastData = null
      let lastLength = 0
      let receiveBuffer
      let bufferLength
      let mySsrc
      mySsrc = 0
      let decoder
      let view
      const initDecoder = {
        output: handleFrame,
        error: (e) => {
          console.log(e.message)
        }
      }
      const configDecoder = {
        codec: _this.obj.codec,
        avc: { format: 'annexb' },
        codedWidth: _this.canvasWidth,
        codedHeight: _this.canvasHeight
      }
      let check
      let size
      let sps

      console.log('链接成功', _this.writerObj)
      while (true) {
        if (!_this.writerObj) {
          console.log('链接断开', _this.writerObj)
          return
        }
        ssrc.setUint32(0, _this.obj.ssrc)
        await this.writerObj.write(ssrc)
        if (ssrc.getUint32(0) !== mySsrc || mySsrc === 0) {
          decoder = new VideoDecoder(initDecoder)
          decoder.configure(configDecoder)
          _this.videoFirst = true
          mySsrc = ssrc.getUint32(0)
        }
        let { done, value } = await reader.read()
        if (done) {
          console.log('已经接收完了所有的视频数据流!')
          return
        }
        if (value.byteLength < 17) {
          continue
        }
        if (lastLength > 0) {
          receiveBuffer = new Uint8Array([...lastData, ...value])
          lastLength = 0
        } else {
          receiveBuffer = new Uint8Array(value.buffer)
        }
        view = new DataView(receiveBuffer.buffer)
        try {
          check = view.getUint32(0)
          size = view.getUint32(17)
          sps = view.getUint32(22)
        } catch {
          console.log('视频无法获取数据')
          continue
        }
        if (check !== 480) {
          continue
        }
        let timestamp = view.getUint32(9)
        let duration = view.getUint32(13)
        let type = view.getUint8(8) === 1 ? 'key' : 'delta'
        if (_this.videoFirst) {
          //   if (sps != 295 && sps != 359) {
          //       continue;
          //   }
          //   else {
          //   }
        }
        while (receiveBuffer.length < size + 21) {
          let { value } = await reader.read()
          receiveBuffer = new Uint8Array([...receiveBuffer, ...value])
        }
        bufferLength = receiveBuffer.length
        if (_this.videoFirst) {
          _this.videoFirst = false
        }
        beginOffset = 0
        lastLength = 0
        let endPrint
        while (bufferLength - beginOffset >= size + 21) {
          const initDecodeParam = {
            type: type,
            data: receiveBuffer.subarray(
              beginOffset + 21,
              beginOffset + 21 + size
            ),
            timestamp: timestamp,
            duration: duration
          }
          try {
            let encoded = new EncodedVideoChunk(initDecodeParam)
            decoder.decode(encoded)
          } catch {
            console.log('解码时出现错误！')
            decoder = new VideoDecoder(initDecoder)
            decoder.configure(configDecoder)
            _this.videoFirst = true
          }
          beginOffset = beginOffset + 21 + size
          if (bufferLength - beginOffset > 21) {
            view = new DataView(receiveBuffer.buffer)
            check = view.getUint32(beginOffset)
            if (check !== 480) {
              if (bufferLength - beginOffset > 100) {
                endPrint = 100
              } else {
                endPrint = bufferLength - beginOffset
              }
              break
            }
            size = view.getUint32(beginOffset + 17)
          } else {
            break
          }
        }
        if (bufferLength - beginOffset > 0) {
          lastLength = bufferLength - beginOffset
          lastData = receiveBuffer.slice(beginOffset)
        } else {
          lastLength = 0
        }
      }
    }
  },
  watch: {
    obj: {
      handler: function (newVal, oldVal) {
        this.setCanvasSize()
      },
      deep: true
    },
    urlSrc() {
      console.log('监听--', this.urlSrc)
      this.loadVideo()
    }
  }
}
</script>
  <style scoped>
.canvas {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}

.canvas canvas {
  background: pink;
}
</style>
  